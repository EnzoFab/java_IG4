// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com import java.io.*;import common.ChatIF;import ocsf.server.*;/** * This class overrides some of the methods in the abstract  * superclass in order to give more functionality to the server. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @version July 2000 */public class EchoServer extends AbstractServer {  //Class variables *************************************************    /**   * The default port to listen on.   */  final public static int DEFAULT_PORT = 5555;    ChatIF serverUI;    //Constructors ****************************************************    /**   * Constructs an instance of the echo server.   *   * @param port The port number to connect on.   */  public EchoServer(int port, ChatIF c)   {    super(port);    this.serverUI = c;  }    //Instance methods ************************************************    /**   * This method handles any messages received from the client.   *   * @param msg The message received from the client.   * @param client The connection from which the message originated.   */  public void handleMessageFromClient    (Object msg, ConnectionToClient client)  {	  if(msg.toString().charAt(0) == '#'){// if we receive a command from the client 		  if(){//check the command, it has to be #login id			  if(client.){// check if the client isn't connected before sending it  				  // boolean and check it with client.getInfo			  }else{				  client.sendToClient("Error you are already connected you can't use this command");			  }			  		  }else{			  client.sendToClient("Error client needs to login first");			  client.close();		  }	  }else{		  System.out.println("Message received: " + msg + " from " + client);		    this.sendToAllClients(msg);	  }      }      /**   * This method overrides the one in the superclass.  Called   * when the server starts listening for connections.   */  protected void serverStarted()  {    System.out.println      ("Server listening for connections on port " + getPort());  }      /**   *    * @param msg   * Handle message typed in the console.   * Allows to execute commands if the message starts with '#'   */  public void handleMessageFromUI(Object msg){	  if(msg.toString().charAt(0) == '#'){		  String c = msg.toString().split("#")[1]; // get the commande without '#'		  String [] str = c.split(" ");		  String command = str[0];		  String parameter= "";		  if(str.length >1){			  parameter= str[1];		  }		  		  switch(command){		  		  	case "quit":		  		if(this.isListening())		  			this.stopListening();				try {					this.close();					System.exit(0);				} catch (IOException e) {					// TODO Auto-generated catch block					System.out.println("Error the server coudn't stop ! ");					e.printStackTrace();				}		  		break;		  				  	case "stop":		  		this.stopListening();		  		System.out.print("Stopped Listenning");		  		break;		  			  	case "close":		  		this.stopListening();		  		System.out.print("Stopped Listenning");				try {					this.close();				} catch (IOException e) {					// TODO Auto-generated catch block					System.out.println("Error the server coudn't stop ! ");					e.printStackTrace();				}		  		break;		  				  	case "getport":		  		System.out.println("Port: "+this.getPort());		  		break;		  			  	case "start":		  		if(!this.isListening()){//if the server isn't listening		  			try {						this.listen();					} catch (IOException e) {						// TODO Auto-generated catch block						e.printStackTrace();					}		  		}else{		  			System.out.println("Error Server is already running ");		  		}		  		break;		  				  	case "setport":		  		if(!this.isListening()){		  			int newp =  Integer.parseInt(parameter);		  			this.setPort(newp);		  			System.out.println("Port has been changed to "+this.getPort());		  		}else		  			System.out.println("Error server is running");		  				  		break;		  	default:		  		System.out.println("Error command unknown");		  }	  }else		  sendToAllClients("Server MSG> "+msg.toString());  }        /**   * This method overrides the one in the superclass.  Called   * when the server stops listening for connections.   */  protected void serverStopped()  {    System.out.println      ("Server has stopped listening for connections.");  }    protected void serverClosed() {	  sendToAllClients("Server is closed");  }    protected void clientConnected(ConnectionToClient client) {	  System.out.println("New Client connected ");  }    synchronized protected void clientDisconnected(ConnectionToClient client)   {	  	  System.out.println("Client is now deconnected ");  }    //Class methods ***************************************************  /*  /**   * This method is responsible for the creation of    * the server instance (there is no UI in this phase).   *   * @param args[0] The port number to listen on.  Defaults to 5555    *          if no argument is entered.     public static void main(String[] args)   {    int port = 0; //Port to listen on    try    {      port = Integer.parseInt(args[0]); //Get port from command line    }    catch(Throwable t)    {      port = DEFAULT_PORT; //Set port to 5555    }	    EchoServer sv = new EchoServer(port);        try     {    	      sv.listen(); //Start listening for connections         }     catch (Exception ex)     {      System.out.println("ERROR - Could not listen for clients!");    }  }*/}//End of EchoServer class